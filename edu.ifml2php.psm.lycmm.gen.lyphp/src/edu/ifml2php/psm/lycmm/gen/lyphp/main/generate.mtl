[comment encoding = UTF-8 /]
[module generate('http://www.application.org/coreMVC', 'http://www.application.org/extPHP','http://www.eclipse.org/uml2/5.0.0/UML')/]

[import edu::ifml2php::psm::lycmm::gen::lyphp::main::helperApplication /]
[import edu::ifml2php::psm::lycmm::gen::lyphp::main::helperFileReader /]
[import edu::ifml2php::psm::lycmm::gen::lyphp::main::helperLaravelInputPaths /]
[import edu::ifml2php::psm::lycmm::gen::lyphp::main::helperController /]

[template public generateElement(anApp : Application) post(trim())]
[comment @main /]

[file ('/laravel5.4.15/config/app', false, 'UTF-8')]
[for (line : String | anApp.getAppConfig().tokenize('\n'))]
	[if (line.contains('name\' =>'))]
		[line.replace('name\' => \'.*\'','name\' => \'' + anApp.name + '\'') /]
	[elseif(line.contains('locale\' =>'))]
		[line.replace('locale\' => \'.*\'','locale\' => \'' + anApp.getLocale() + '\'')/]
	[else]
		[line/]
	[/if]
[/for]
[/file]

[comment]Puedo usar la función reflexiva de Java Class.getDeclaredFields() para solicitar, mediante un servicio, los atributos de la clase. Una vez que los tengo puedo iterar a través de ellos para hacer la sustitución del lado derecho de los Strings en el archivo de configuración. Si por alguna razón no quiero traer todos los atributos, podría crear un array de atributos exportados. Contra: el nombre del atributo en la clase Java deberá ser igual al parámetro de configuración que se quiere cambiar. Solución: Agregar un Adapter que haga el mapeo. Sin embargo: cuántos menos cosas puedan ir mal, menos cosas lo harán. Buscamos minimizar las dependencias, de alguna manera ya existen bastantes. [/comment]

[ self.makeModels(aPackageModel) /]
[ self.makeViews(aPackageView) /]
[ self.makeControllers(aPackageController) /]

[/template]

[comment]La plantilla utilizada para los modelos y los controladores es la generada por el uso del comando php artisan make:[controller|model] <name> --resource[/comment]

[template private makeViews(pv : PackageView)]
    [let base_dir : String = 'FHS/var/www/html/' ] [comment]FHS + getBaseDir()[/comment] 
	[let path : String = 'laravel5.4.15/resources/' + pv.name + 'Views/']
      [ self.makeFolder(base_dir + path) /]
      [for (view : View | pv.views )]
	     	[self.writeView(path, view)/]
      [/for]
   [/let]
[/let]
[/template]

[template public writeModelSkeleton(path : String, model : Model)]
[file (path + model.name + '.php', false, 'UTF-8')]
<?php

namespace App\[(path.tokenize('/'))->asSequence()->last() /];
	
use Illuminate\Database\Eloquent\Model;
		
class [model.name /] extends Model
{
	protected $table = '[model.name.toLowerCase().concat('s') /]' ; 
	
	[comment]TODO:
	* protected $fillable = ['['/][']'/]; TODO: este vector podría obtenerse desde IFMLModel	
	* se podrían generar las relaciones entre modelos para la persistencia:
		public function othermodel(){
			return $this->typeRelation(othermodelUri)...
		}[/comment]
	
}
[/file]
[/template]

[template private makeModels(pm : PackageModel)]
    [let base_dir : String = 'FHS/var/www/html/' ]
	[let path : String = 'laravel5.4.15/app/' + pm.name + 'Models/']
      [ self.makeFolder(base_dir + path) /]
      [for (model : Model | pm.models)]
	     [ self.writeModelSkeleton(path, model)/]
      [/for]
   [/let]
[/let]
[/template]

[template private makeControllers(pc : PackageController)]
    [let base_dir : String = 'FHS/var/www/html/' ]
	[let path : String = 'laravel5.4.15/app/Http/Controllers/' + pc.name + 'Controllers/']
      [ self.makeFolder(base_dir + path) /]
      [for (controller : Controller | pc.controllers )]
	      [self.writeControllerSkeleton(path, controller)/]
      [/for]
   [/let]
[/let]
[/template]


[template public writeControllerSkeleton(path : String, controller : Controller)]
[file (path + controller.name + '.php', false, 'UTF-8')]
<?php

namespace App\Http\Controllers\[(path.tokenize('/'))->asSequence()->last() /];

use Illuminate\Http\Request;



class [controller.name/] extends Controller
{
[for (method : Method | controller.methods)]

   protected function [ method.name /]([for (parameter : Attribute | method.inParameters) separator(', ' )]$[parameter.name/][/for])
   {   
    [if ( method.outParameters->size() > 0)]
    	//Los parámetros ([for (parameter : Attribute | method.outParameters) separator(', ' )]$[parameter.name/][/for]) fueron modelados como de salida. Verifique si son retornados al módulo llamador o pasado a otro 
    [else]
	
    	[comment]Formatting Purpose Blank line[/comment]
	[/if] 
   }
  
	
	[comment]TODO:
		* Ver como obtener el scope de los métodos. No encontramos manera de hacerlo desde IFML-Metamodel aún.
		* Usar los outParameters de manera más precisa obteniendo información de los Interaction Flows.[/comment]
[/for]	
[ self.getControllerBoilerplate() /]
[comment]TODO: *Podrían usarse 2 templates, uno que coloque los métodos personalizados al comienzo y otro que los coloque al final.
Incluso, se podría poner a los métodos en un orden tal que sea significativo para facilitar la lectura.[/comment]  
}
[/file]
[/template]

[template public writeView(path : String, view : View)]
[file (path + view.name + '.php', false, 'UTF-8')]
	[for (viewComponent : ViewComponent | view.viewComponents)]
		[if (viewComponent.oclIsTypeOf(Anchor))]
			[let anchor : Anchor = viewComponent] [comment]En lugar de usar los pairedTag y emptyTag casteamos el viewComponent a Anchor. Esto simplifica el código y mejora la legibilidad a la vez que permite flexibilidad en la implementación (podría no hacerse el cast y utilizar estos atributos)[/comment]
<[ anchor.tagName /] href="[ anchor.hypRef /]" target="[ anchor.target /]" >[ anchor.name /]</[ anchor.tagName /]>
[comment]Para no definir exhaustivamente y con código estático los atributos de los HTMLElements, podría utilizarselos como su representación ECore (EAttributes). El problema que surge es que EAttribute no tiene algo así como un value más allá de default (lo cuál es totalmente correcto), por lo cual tendríamos que necesitar aún castear ese HTMLElement a un elemento determinado, por lo cual no se aprovecharía la mayor ventaja de este enfoque: permitir la adición de atributos a los HTMLElement (por ej., conforme a alguna nueva especificación) en el metamodelo, sin tener que modificar las reglas -al menos- M2T. Nótese que también este enfoque aumentaría la abstracción del metamodelo de los frameworks PHP(lo cual no es malo) pero haría perder expresividad a los modelos que lo conformen[/comment]
			[/let]
		[/if]
		
	[/for]
[/file]
[/template]